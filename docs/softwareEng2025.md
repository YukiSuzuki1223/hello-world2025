---
layout: page
title: "Software Eng. Lecture note"
permalink: /docs/softwareEng2025
---

# ソフトウェア工学2025 講義まとめ

このページでは、ソフトウェア工学2025の講義内容を回ごとにまとめています。

ソフトウェア講義１

第1回の講義では、ソフトウェア工学という学問の概要と、この講義を通じて何を学ぶべきかが示された。特に、ソフトウェア開発における「体系的な知識」と「実務的なスキル」の両立の重要性が強調された。 ソフトウェア工学の学習目的として、単なるプログラミング技術の習得ではなく、「品質・コスト・納期」を最適化するための方法論を理解し、応用することが挙げられた。つまり、ソフトウェアを効率的に、かつ持続可能に設計・開発・保守するための知見を得ることが目標である。 また、ソフトウェア工学が難しいとされる理由として、以下の三点が挙げられた。 ・実務と知見のギャップ：実際に開発経験がない学生にとって、抽象的な知見だけでは現場をイメージしにくい。 ・知見と実践の乖離：理論を理解しても、それを現場で活用するには応用力が求められる。 ・チームでの知識共有の必要性：個人の知識では限界があり、チーム全体での連携が不可欠である。 加えて、講師の個人的な経験談が紹介され、実社会におけるソフトウェア工学の重要性が具体的に示された。たとえば、IT未経験からエンジニアとなった事例や、継続的なシステム更新の必要性、FOSS4G（Free Open Source Software for Geospatial）プロジェクトへの関わりなどが挙げられ、ソフトウェア開発が単なる技術活動ではなく、社会的・人的な側面とも密接に関わることがわかった。

また、近年のAIの進展に伴い、LLM（大規模言語モデル）による自動ソフトウェア生成が可能となる時代においても、開発を監督し品質や要件を担保する役割は人間が担う必要があることが述べられた。すなわち、AIに任せられる部分が増えても、ソフトウェア工学の知識を持つエンジニアの役割は今後ますます重要になると考えられる。

ソフトウェア講義２

第2回の講義では、ソフトウェア工学の基本的な定義とその目的、そしてソフトウェア開発における課題と対応の考え方について学んだ。特に印象的だったのは、ソフトウェアというものの本質的な性質と、それに対する工学的アプローチの必要性である。 まず、ソフトウェアとは何かという問いに対し、単にプログラムの集合ではなく、「命令語（プログラム）」「データ構造」「操作マニュアル等の関連情報」からなる総合的な構造物であることが示された。これは、ソフトウェアが情報を扱うシステムであり、動作させるための手順や使い方までもが製品の一部であることを意味する。 また、ハードウェアと異なりソフトウェアは物理的に劣化しないが、環境や技術、ビジネス要件の変化に適応できなくなることで“悪化”するという点が強調された。そのため、ソフトウェアは常に進化し続ける必要があり、その過程を適切に管理・設計するためにソフトウェア工学の知識が不可欠となる。 講義ではIEEEの定義に基づき、ソフトウェア工学は「ソフトウェアの開発、運用、保守に対する体系的、規律的、かつ定量的なアプローチの適用」であると紹介された。単なる開発技術ではなく、プロジェクト全体を管理し、品質・コスト・納期を調整する枠組みとしての役割がある。 加えて、実務におけるソフトウェア開発の進め方について、問題解決の4ステップ（問題の理解・解決策の計画・実装・検証）が提示され、これは今後の演習や実プロジェクトを進める際の基本的な枠組みになると理解した。 さらに、Hookerの提唱する7つの原則が紹介され、以下のような姿勢が求められることを学んだ： ・システムはユーザーに価値を与えるものであることを忘れない ・設計は常にシンプルであるべき（KISS原則） ・明確なビジョンを持ち続ける ・他人に伝わるコード・設計・文書を書く ・未来に対応できるようオープンに設計する ・再利用を計画段階から考える ・行動の前に考える習慣をつける これらの原則は、単なる技術力だけでなく、開発者としての態度や責任感も重要であることを示しており、将来ソフトウェア開発に関わる者として心に留めておきたいと感じた

ソフトウェア講義３

第3回の講義では、ソフトウェアがどのような過程を経て企画・開発・運用・廃止されるのかという一連の流れ、すなわち「ソフトウェアライフサイクル」について学んだ。 まず、ソフトウェアライフサイクルは以下の三つの主要な段階から構成される。 企画・要件定義フェーズ 　この段階では、ビジネス的・技術的なニーズに基づき、「どのようなソフトウェアが必要か」「それによって業務がどう変わるのか」といった点を明らかにする。要件定義書では、目的や概要、機能、構成、目標性能、インターフェース仕様、運用条件、制限事項、開発スケジュールなどが明文化される。 設計・実装フェーズ 　要件定義書に基づき、システムの構成やモジュール設計が行われ、プログラムとして具現化される。このとき、WBS（Work Breakdown Structure）を用いて作業を分解・整理し、内製か外注か、あるいはオフショア開発かといった手法の選定も行われる。 運用・保守・廃止フェーズ 　稼働中のソフトウェアは、使用状況や発生する問題に応じて修正・改善が施される。また、最終的にはサービス終了やシステム更改を迎えることになる。このとき、運用中に得られたデータや知見を次の開発に生かすことが望ましい。 講義では、「テストとデバッグ」についても詳しく触れられた。完全にバグのないソフトウェアは存在しないという前提に立ち、いかにしてバグの影響を最小限に抑えるかが重要である。工数の制約からすべてをテストすることは困難であり、どの部分をどの程度テストするかを判断するスキルが求められる。 さらに、運用後のソフトウェアは開発者が関与していない場合も多く、適切な**ドキュメンテーション（文書化）**が不可欠であると強調された。特に、海外の企業との連携やオープンソース利用の増加により、英語による文書作成能力も必要となる。

ソフトウェア講義４

第4回の講義では、「プロジェクト」と「ソフトウェア分析」という2つの重要なテーマについて学んだ。 まず、「プロジェクト」とは何かについて定義が示された。プロジェクトは有期性と独自性を持つ活動であり、ソフトウェア開発はその典型的な例とされる。つまり、プロジェクトは「限られた期間の中で、特定の目的を達成するために一度きり行われる業務」であり、継続的なルーチンワークとは異なる。 次に、目標設定と計画のアプローチとして、「フォアキャスティング（forecasting）」と「バックキャスティング（backcasting）」という2つの視点が紹介された。前者は現在の状況から積み上げて将来を予測するものであり、学校の勉強などに適している。一方、後者は最終的な目標から逆算して必要なステップを計画するもので、ソフトウェア開発のようなプロジェクトにはこの考え方が有効である。目標達成を確実にするためには、最初にビジョンを明確に設定し、その実現に必要な行動を段階的に設計する必要がある。 後半では、ソフトウェア分析の基礎について学習した。ここでは、品質（Quality）、コスト（Cost）、納期（Delivery）というQCDの観点からソフトウェアを評価する手法が取り上げられた。特に、以下の4つの分析指標が紹介された。 ・コードの物量（ステップ数）：総ソースコード行数によって開発規模を定量化する。 ・コードの物量（オブジェクト容量）：主に組み込み系ソフトウェアにおいて、メモリやストレージ制約を評価する。 ・ファンクションポイント（FP）法：開発前に要件から規模を見積もる手法。以下の式が用いられる： 　FP値 = 基準値 × (0.65 + 調整値 / 100) 　原価 = FP値 × 単価 × 換算係数 ・使い勝手の評価：画面の視認性、操作性、互換性など、ユーザビリティに関する主観的要素の分析。 また、ソフトウェアの品質に関連して「バグ発生率」や「Hyrumの法則」が紹介された。バグ発生率は「バグ件数 ÷ ステップ数」で求められ、品質管理の一指標とされる。一方、Hyrumの法則とは、APIの仕様として明示されていない振る舞いにもユーザーが依存するようになるというものであり、変更の影響範囲が広がりやすいソフトウェアの特性を端的に表している。

ソフトウェア講義５

第5回の講義では、プロジェクト管理において極めて重要な概念であるWBSについて学んだ。 wBSとは、プロジェクトの目標達成に必要な「要素成果物」を起点として、それを実現するための作業を段階的に細分化した構成図である。各作業は「Work」として定義され、全体を「Breakdown（分解）」し、「Structure（構造化）」することによって、何を、誰が、いつまでに行うのかが一目で分かるようになる。 WBSを作成するうえで重要とされたのは、以下のような考え方である： ・トップダウンアプローチ 　まずプロジェクト全体のスコープを明確にしたうえで、そこから大分類（フェーズ）→中分類（タスク群）→小分類（具体的な作業）へと順に分解していく。これはボトムアップではなく、目標から逆算する「バックキャスティング」の発想に基づいている。 ・グルーピングと順序関係の整理 　関連する作業は論理的にまとめ、各グループ間の順序関係（例：データ収集 → 分析 → 可視化）を意識することで、作業の流れを明確にする。 ・MECE（Mutually Exclusive, Collectively Exhaustive）の原則 　作業を「漏れなく、重複なく」列挙することで、抜けやムダのないWBSを作成する。 さらに、実践的な演習として、学生は「情報工学科の学生によるゲーム大会の企画・運営」を題材にWBSを作成する課題が課された。この中では、「準備」「設営」「本番」「片付け」といったフェーズを設定し、それぞれのタスクを細分化したうえで、3人のメンバー（私、友人A、友人B）に役割をアサインすることが求められた。タスクごとに開始日・終了日を記入し、スケジュールの整合性を取ることも重要である。この演習を通じて、WBSの有効性を実感することができた。特に、プロジェクトを構造的に捉えることで、「何が未決定なのか」「どこにリスクがあるのか」を可視化でき、計画段階での意思決定やリソース配分がより合理的に行えると感じた。

ソフトウェア講義６

この講義の中心は、学生自身がプロジェクトマネージャーとなって仮想プロジェクト（情報工学科の学生交流を目的とした「ゲーム大会」）のWBSを作成するという実践課題である。具体的には、プロジェクトを構成するすべての作業を、準備・当日運営・後片付けなどのフェーズに分け、それぞれを階層的にタスクへと分解していくことが求められた。 作成にあたっての重要な要点は以下の通りである： ・スコープの明確化 　プロジェクトの目的、規模、想定条件（日時・場所・参加人数・使用ゲームの種類など）を初期段階で明文化することが求められた。これはWBSの最上位構造を決定するうえで不可欠である。 ・タスクの洗い出しと分類 　例えば、「備品準備」「ルール説明」「司会進行」「景品手配」「サイドイベントの設計」など、各フェーズに必要な作業を細分化し、漏れなく記載することが求められた。また、実行者（自分、友人A、友人B）の役割分担や実施日程も設定し、現実的なスケジュールに落とし込んでいく。 ・WBSの構造的整合性と実行可能性 　分解されたタスクは論理的な順序と依存関係を持ち、重複や曖昧さが生じないよう「MECE（Mutually Exclusive, Collectively Exhaustive）」の原則に基づいて整理する必要がある。例えば、設営作業は大会当日より前でなければならず、片付けは最終タスクとなるべきである。 WBS作成を通して得られた最も大きな学びは、「計画段階でいかに具体化できるか」がプロジェクトの成否を分けるという点である。目に見えない作業も明示的に書き出し、責任と期間を明確化することで、作業の漏れ・遅延を未然に防ぐことが可能となる。

ソフトウェア講義７

第7回の講義では、ソフトウェア開発における「コーディング」の実践的な知識と、その背景にあるスタイルガイドの意義について学んだ。まず、「コードは書かれるより読まれる回数の方が多い」という原則が示された。読みやすさとは主観的な感覚ではなく、具体的なスタイルガイドによって定義され、チーム全体の共通認識として徹底されるべきものである。具体的な例として、Pythonの公式スタイルガイド「PEP8」が取り上げられた。これはPythonプログラムの可読性と一貫性を保つための規約であり、行の長さ、インデント、スペースの使い方、改行位置、コメントの記述方法、識別子の命名規則など、多岐にわたる指針が与えられている。特に、インデントはタブではなくスペース4つを用いること、行は原則79文字以内に収めること、演算子の前後にスペースを入れることなど、視覚的な整合性を保つための具体的なルールが印象に残った。
また、命名規則においても、関数・変数はスネークケース（例：calculate_area）、クラスはキャメルケース（例：ShapeCalculator）、定数は全て大文字で表記（例：PI_VALUE）するなど、役割に応じた命名方法が紹介され、コードの役割や意味が自然に伝わるような設計が求められることを理解した。
加えて、講義ではPEP8を自動的にチェックするツールとしてLinter「flake8」が紹介され、コーディング規約を遵守しているかどうかを機械的に検出することで、開発初期から品質の高いコードを保つ手段となることが示された。実際にflake8を使った演習を通して、具体的にどの部分がスタイル違反であるかを把握し、それを修正するプロセスを体験したことは、今後の開発実践において有用な経験となった。

ソフトウェア講義８

第8回の講義では、ソフトウェア開発における「バージョン管理」の基礎とその重要性について学んだ。特に印象的だったのは、ソフトウェアが時間とともに変化・進化するものである以上、その変更履歴を正確に管理することが、開発の継続性や品質保証において不可欠であるという認識だ。講義の冒頭では、バージョン管理とは、ファイルが「いつ」「誰によって」「どのように」変更されたのかを記録・追跡する仕組みであると定義された。この仕組みがなければ、共同作業中に生じる競合（conflict）や意図しない上書きなどのトラブルが頻発し、プロジェクト全体の信頼性が著しく低下する。バージョン管理は、個人開発における保守性向上はもちろん、チーム開発における変更の見える化と責任の明確化を実現する手段であると理解した。講義では、バージョン管理の方法として、集中管理型（Subversionなど）と分散管理型（Gitなど）の2つが紹介された。特に注目すべきは分散管理型のGitであり、これは各開発者がローカルにレポジトリ（履歴付きの開発環境）を持ち、それぞれが独立してバージョン管理を行えるという特徴を持つ。そのため、リモートサーバにアクセスできない環境でも作業が継続でき、障害に対する耐性が高い。また、リモートリポジトリとの同期（push/pull）によって、チームメンバーとのコード共有や統合も柔軟に行える。また、Gitでは「ワークツリー（作業領域）」「ステージングエリア（インデックス）」「Gitディレクトリ（履歴領域）」の3つの領域が連携して動作しており、それぞれの役割を正しく理解することが重要であるとされた。具体的には、ワークツリー上のファイルを編集し、ステージングエリアでコミット対象を選び、Gitディレクトリで履歴として永続化するという一連の流れが、ソフトウェアの変更管理を構造的に支える基盤となっている。

ソフトウェア講義１０

講義ではまず、Gitの基本操作に関する演習教材「Learn Git Branching」を用いて、コミットの概念、ブランチの操作、履歴の可視化などを視覚的に学習した。Gitは「変更の集合」を履歴として記録するシステムであり、過去の状態への復元、変更の追跡、複数の作業の並行管理が可能となる。こうした機能は、特にチーム開発において、予期せぬバグや競合が発生した際の迅速な対応を可能にする。
また、git initによるリポジトリの初期化、git addでのステージング、git commitによる変更の記録など、バージョン管理の基本的なコマンドを一つずつ確認し、操作の背後にある概念を丁寧に整理した。git statusやgit logといった確認系コマンドを通じて、リポジトリの状態を常に把握することの重要性も学んだ。また、コミットの修正や取り消しに関する操作として、git commit --amend（コミットの修正）、git revert（変更を打ち消す新たなコミットを作成）、git reset（指定した地点まで履歴を巻き戻す）といったコマンドが紹介され、それぞれの違いや注意点を把握することができた。特に、Gitの設計思想として「履歴をむやみに改変すべきではない」という前提があり、そのうえで安全に修正・復元する方法が用意されているという点は、ソフトウェア工学的に堅牢な履歴管理の思想として納得感があった。さらに、リモートリポジトリとの連携に関しても基本的な操作が紹介され、git clone、git pull、git pushといったコマンドによって、ローカルとリモート間での同期を行う開発フローが理解できた。これらはGitHubなどの共有サービスと連携して使う際の基礎技術であり、チームでの協働作業やオープンソース開発の場面で不可欠な要素である。

ソフトウェア講義１１

第11回の講義では、前回に引き続きバージョン管理の実践的スキルとして、GitHubを利用した開発フローとその機能について学んだ。
講義ではまず、GitHub上での一般的な開発フロー、すなわち「GitHubフロー」について紹介された。GitHubフローでは、開発者がリモートレポジトリをfork（分岐）して独自のコピーを作成し、そこからcloneしてローカル環境で作業を行い、変更内容をpushしてプルリクエストを送信し、レビュー・マージされるという一連のプロセスが基本となる。このような仕組みにより、オープンソース開発などの大規模分散型開発でも、コードの整合性と品質を保つことが可能となっている。
また、GitHubには「issues」と呼ばれる課題管理機能があり、バグ報告・機能要望・質問などをチケットとして管理することができる。これはRedmineやJiraなどのプロジェクト管理ツールと類似しており、開発チーム内でのタスク共有や進捗確認を可視化する手段として非常に有効であると理解した。
さらに、「projects」機能では、issuesをカンバン方式で整理・管理することができる。これにより、チームメンバーが現在何を担当し、どこまで進んでいるのかを直感的に把握することが可能となる。このような可視化されたタスク管理は、アジャイル開発との親和性が高く、プロジェクトの柔軟な運営を支える重要な仕組みであると感じた。加えて、実際にGitHub上で演習課題としてREADMEファイルを用いたレポジトリ構築を行った。ここでは、Markdown形式のREADMEファイルを作成し、GitHub上での自己紹介ではなく「演習課題の内容説明」として記述することが求められた。Markdownは簡潔に構造化された文書を記述するための記法であり、GitHubだけでなく多くの技術系ドキュメントでも使用されていることから、情報の正確かつ簡潔な提示手段としての技術的価値を実感した。

ソフトウェア講義１２

第12回の講義では、近年のソフトウェア開発において中核的な役割を担うCI/CD（継続的インテグレーション／継続的デリバリー）の概念と、その実現手段としてのGitHub Actionsの基本構造について学んだ。特に印象的だったのは、CI/CDの導入によって、開発プロセスの品質・速度・信頼性が飛躍的に向上するという点である。
まず、CI（Continuous Integration）とは、開発者が行ったコード変更を頻繁に共有リポジトリに統合し、自動でビルドやテストを行うプロセスである。これにより、バグの早期発見と修正が可能となり、統合時のトラブルを未然に防ぐことができる。一方、CD（Continuous Delivery／Deployment）は、テスト済みのコードを自動でデプロイ環境に展開することで、リリースの迅速化と人為的ミスの削減を実現する。講義では、CI/CDの一連の流れが「ソース → ビルド → テスト → デプロイ → 検証 → モニタリング」というステップで構成されていることが示され、それぞれの段階がソフトウェアの信頼性と持続性を支える重要な要素であると理解した。
次に、GitHub Actionsを用いたCI/CDの設定方法について具体的に学習した。GitHub Actionsでは、.github/workflows/ディレクトリ内に配置されたYAMLファイルによって、ワークフロー（処理手順）を記述する。YAMLはインデントで構造を表現する形式であり、非常に可読性が高い。ワークフローには、トリガー（例：pushやpull_request）、ジョブ（実行環境）、ステップ（処理内容）が定義されており、これにより柔軟かつ再利用可能な自動化プロセスが構築されることを学んだ。

ソフトウェア講義13

第13回では、CI/CDの応用として、GitHub Pagesを使ったWebページの自動公開を実践的に学んだ。
GitHub Pagesは、GitHubにあるリポジトリの内容をHTML化し、そのままWebサイトとして公開できる機能であり、開発した内容や記録を外部に共有するための手段として非常に有用だ。特に今回は、Jekyllという静的サイトジェネレータを使うことで、Markdown形式で書かれた文書が自動でWebページに変換される仕組みが導入された。開発者にとって、HTMLやCSSに直接触れることなくサイト構築ができるのは大きな利点であると感じた。
設定手順としては、まずリポジトリ名を <ユーザー名>.github.io とし、GitHub Pagesのビルド方式を「GitHub Actions」に変更。その後、docsディレクトリ内でJekyllを初期化し、_config.yml や index.markdown を編集することで、ページ構成やタイトル、公開対象のファイルを調整した。また、softwareEng2025.md にまとめた講義内容を docs に移動し、トップページからリンクする形で構成を完成させた。こうした一連の作業を通じて、Webサイトの更新がコードのpushによって自動で行われるという、CI/CDの基本的な考え方がより具体的に理解できた。特に、GitHub ActionsがYAMLファイルに定義されたワークフローに従って動作し、ビルド・デプロイが全自動で完結する点に、実務でも十分応用可能な柔軟性と効率性を感じた。